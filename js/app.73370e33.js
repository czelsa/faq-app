(function(){"use strict";var e={8596:function(e,n,a){var o=a(3751),t=a(641);const i={id:"app"};function r(e,n,a,o,r,s){const c=(0,t.g2)("router-link"),l=(0,t.g2)("router-view");return(0,t.uX)(),(0,t.CE)("div",i,[(0,t.Lk)("nav",null,[(0,t.bF)(c,{to:"/"},{default:(0,t.k6)((()=>[(0,t.eW)("Home")])),_:1}),(0,t.bF)(c,{to:"/python"},{default:(0,t.k6)((()=>[(0,t.eW)("Python")])),_:1}),(0,t.bF)(c,{to:"/javascript"},{default:(0,t.k6)((()=>[(0,t.eW)("JavaScript")])),_:1})]),(0,t.bF)(l)])}var s={name:"App"},c=a(6262);const l=(0,c.A)(s,[["render",r]]);var d=l,u=a(6166);const p=(0,t.Lk)("h1",null,"Home",-1),y=(0,t.Lk)("p",null,"Wybierz temat z górnego menu, aby zobaczyć pytania i odpowiedzi.",-1),w=(0,t.Lk)("span",null,"Pytania i odpowiedzi wygenerowa chatGPT",-1),m=[p,y,w];function z(e,n,a,o,i,r){return(0,t.uX)(),(0,t.CE)("div",null,m)}var k={name:"HomeView"};const h=(0,c.A)(k,[["render",z]]);var j=h;const g=e=>((0,t.Qi)("data-v-d68874ee"),e=e(),(0,t.jt)(),e),f=g((()=>(0,t.Lk)("h1",null,"Python FAQ",-1)));function b(e,n,a,o,i,r){const s=(0,t.g2)("QuestionList");return(0,t.uX)(),(0,t.CE)("div",null,[f,(0,t.bF)(s,{questions:i.questions},null,8,["questions"])])}const _={class:"search-container"},v={key:0},x=(0,t.Lk)("p",null,"Brak takiego pytania",-1),C=[x];function q(e,n,a,i,r,s){const c=(0,t.g2)("QuestionItem");return(0,t.uX)(),(0,t.CE)("div",null,[(0,t.Lk)("div",_,[(0,t.bo)((0,t.Lk)("input",{"onUpdate:modelValue":n[0]||(n[0]=e=>r.search=e),placeholder:"Search questions..."},null,512),[[o.Jo,r.search]]),r.search?((0,t.uX)(),(0,t.CE)("button",{key:0,onClick:n[1]||(n[1]=(...e)=>s.clearSearch&&s.clearSearch(...e)),class:"clear-button"},"X")):(0,t.Q3)("",!0)]),0===s.filteredQuestions.length?((0,t.uX)(),(0,t.CE)("div",v,C)):(0,t.Q3)("",!0),((0,t.uX)(!0),(0,t.CE)(t.FK,null,(0,t.pI)(s.filteredQuestions,((e,n)=>((0,t.uX)(),(0,t.Wv)(c,{key:n,item:e,index:n},null,8,["item","index"])))),128))])}var P=a(33);const M=e=>((0,t.Qi)("data-v-0d00dc07"),e=e(),(0,t.jt)(),e),O={class:"accordion-item"},J={key:0},D={key:1},S={class:"answer"},E=["innerHTML"],T={key:1},A={key:2},F=M((()=>(0,t.Lk)("strong",null,"Explanation:",-1))),L=["href"];function I(e,n,a,i,r,s){return(0,t.uX)(),(0,t.CE)("div",O,[(0,t.Lk)("div",{onClick:n[0]||(n[0]=(...e)=>s.toggle&&s.toggle(...e)),class:"question"},[(0,t.Lk)("h3",null,(0,P.v_)(a.index+1)+". "+(0,P.v_)(a.item.question),1),r.show?(0,t.Q3)("",!0):((0,t.uX)(),(0,t.CE)("span",J,"+")),r.show?((0,t.uX)(),(0,t.CE)("span",D,"-")):(0,t.Q3)("",!0)]),(0,t.bF)(o.eB,{name:"accordion"},{default:(0,t.k6)((()=>[(0,t.bo)((0,t.Lk)("div",S,[a.item.answer?((0,t.uX)(),(0,t.CE)("div",{key:0,innerHTML:s.formattedAnswer},null,8,E)):(0,t.Q3)("",!0),a.item.code?((0,t.uX)(),(0,t.CE)("pre",T,[(0,t.Lk)("code",{ref:"codeBlock",class:(0,P.C4)(s.languageClass)},(0,P.v_)(a.item.code),3)])):(0,t.Q3)("",!0),a.item.explanation?((0,t.uX)(),(0,t.CE)("p",A,[F,(0,t.eW)(" "+(0,P.v_)(a.item.explanation),1)])):(0,t.Q3)("",!0),a.item.link?((0,t.uX)(),(0,t.CE)("a",{key:3,href:a.item.link,target:"_blank"},"Learn more",8,L)):(0,t.Q3)("",!0)],512),[[o.aG,r.show]])])),_:1})])}var V=a(9878),R=(a(1732),{name:"QuestionItem",props:{item:Object,index:Number},data(){return{show:!1}},computed:{formattedAnswer(){return this.item.answer.replace(/\n/g,"<br>")},languageClass(){if(this.item.code){if(this.item.code.includes("import")||this.item.code.includes("def")||this.item.code.includes("print"))return"language-python";if(this.item.code.includes("console.log")||this.item.code.includes("function"))return"language-javascript"}return""}},methods:{toggle(){this.show=!this.show,this.$nextTick((()=>{this.show&&this.$refs.codeBlock&&V.A.highlightElement(this.$refs.codeBlock)}))}}});const H=(0,c.A)(R,[["render",I],["__scopeId","data-v-0d00dc07"]]);var W=H,U={name:"QuestionList",components:{QuestionItem:W},props:{questions:Array},data(){return{search:""}},computed:{filteredQuestions(){return this.questions.filter((e=>e.question.toLowerCase().includes(this.search.toLowerCase())))}},methods:{clearSearch(){this.search=""}}};const N=(0,c.A)(U,[["render",q]]);var B=N,Q=JSON.parse('[{"question":"Jakie są nowości w Pythonie 3.9 i 3.10?","answer":"Python 3.9 wprowadził takie nowości jak operatory związków zbiorów (merge operators) dla słowników, nowe metody stringów str.removeprefix() i str.removesuffix(), a także typy unii w anotacjach. Python 3.10 wprowadził strukturalne pattern matching, lepszą informację o błędach składniowych oraz ulepszone zarządzanie wyjątkami.","code":"dict1 = {\'a\': 1, \'b\': 2}\\ndict2 = {\'b\': 3, \'c\': 4}\\nmerged_dict = dict1 | dict2\\n# Result: {\'a\': 1, \'b\': 3, \'c\': 4}\\n\\ndef http_error(status):\\n    match status:\\n        case 400:\\n            return \'Bad request\'\\n        case 404:\\n            return \'Not found\'\\n        case 500:\\n            return \'Server error\'\\n        case _:\\n            return \'Unknown error\'\\n","link":"https://docs.python.org/3/whatsnew/3.9.html"},{"question":"Jakie są różnice między listą, tuplą a zbiorem?","answer":"Mutowalność:\\n\\nLista: Mutowalna, można zmieniać zawartość (dodawać, usuwać, modyfikować elementy).\\nTupla: Niemutowalna, nie można zmieniać zawartości po utworzeniu.\\nZbiór: Mutowalny, można dodawać i usuwać elementy, ale elementy muszą być unikalne.\\n\\nSposób definiowania:\\n\\nLista: Nawiasy kwadratowe ([]).\\nTupla: Nawiasy okrągłe (()).\\nZbiór: Nawiasy klamrowe ({}) lub funkcja set().\\n\\nUnikalność elementów:\\n\\nLista: Może zawierać duplikaty.\\nTupla: Może zawierać duplikaty.\\nZbiór: Nie może zawierać duplikatów.\\n\\nPorządek:\\n\\nLista: Zachowuje kolejność elementów.\\nTupla: Zachowuje kolejność elementów.\\nZbiór: Nie zachowuje kolejności elementów.\\n\\nZastosowania:\\n\\nLista: Używana do przechowywania zbiorów elementów, które mogą się zmieniać.\\nTupla: Używana do przechowywania zbiorów elementów, które nie powinny się zmieniać.\\nZbiór: Używany do przechowywania unikalnych elementów i wykonywania operacji matematycznych na zbiorach (jak unia, przecięcie, różnica).","code":"# Lista\\nmoja_lista = [1, 2, 3, 3]\\nprint(moja_lista)  # Output: [1, 2, 3, 3]\\n\\n# Tupla\\nmoja_tupla = (1, 2, 3, 3)\\nprint(moja_tupla)  # Output: (1, 2, 3, 3)\\n\\n# Zbiór\\nmoj_zbior = {1, 2, 3, 3}\\nprint(moj_zbior)  # Output: {1, 2, 3}","link":"https://docs.python.org/3/tutorial/datastructures.html"},{"question":"Czym są comprehensions w Pythonie? Podaj przykłady.","answer":"Comprehensions to wygodna metoda tworzenia list, setów, słowników i generatorów w jednym wierszu kodu. Pozwalają na bardziej zwięzły i czytelny kod.","code":"squares = [x**2 for x in range(10)]\\n# Result: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\\n\\nunique_squares = {x**2 for x in range(10)}\\n# Result: {0, 1, 4, 9, 16, 25, 36, 49, 64, 81}\\n\\nsquare_dict = {x: x**2 for x in range(10)}\\n# Result: {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}\\n","link":"https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions"},{"question":"Jakie są różnice między deepcopy a shallow copy?","answer":"Shallow copy kopiuje obiekt, ale nie kopiuje obiektów zagnieżdżonych. Deepcopy tworzy pełną kopię obiektu wraz z wszystkimi obiektami zagnieżdżonymi.","code":"import copy\\noriginal = [1, [2, 3], 4]\\nshallow = copy.copy(original)\\nshallow[1][0] = \'a\'\\n# original: [1, [\'a\', 3], 4]\\n\\nimport copy\\noriginal = [1, [2, 3], 4]\\ndeep = copy.deepcopy(original)\\ndeep[1][0] = \'a\'\\n# original: [1, [2, 3], 4]\\n# deep: [1, [\'a\', 3], 4]\\n","link":"https://docs.python.org/3/library/copy.html"},{"question":"Czym są dekoratory i jak działają?","answer":"Dekoratory to funkcje, które przyjmują inną funkcję jako argument, rozszerzając jej funkcjonalność bez zmiany jej kodu.","code":"def my_decorator(func):\\n    def wrapper():\\n        print(\'Something is happening before the function is called.\')\\n        func()\\n        print(\'Something is happening after the function is called.\')\\n    return wrapper\\n\\n@my_decorator\\ndef say_hello():\\n    print(\'Hello!\')\\n\\nsay_hello()\\n# Output:\\n# Something is happening before the function is called.\\n# Hello!\\n# Something is happening after the function is called.\\n","link":"https://realpython.com/primer-on-python-decorators/"},{"question":"Co to są konteksty menedżerów (context managers) i jak się ich używa?","answer":"Context managers to obiekty, które zarządzają zasobami, zapewniając ich prawidłowe zamknięcie lub zwolnienie po zakończeniu pracy. Używa się ich za pomocą instrukcji \'with\'.","code":"with open(\'file.txt\', \'r\') as file:\\n    data = file.read()\\n# File is automatically closed after the block\\n\\nfrom contextlib import contextmanager\\n\\n@contextmanager\\ndef my_context_manager():\\n    print(\'Entering the context\')\\n    yield\\n    print(\'Exiting the context\')\\n\\nwith my_context_manager():\\n    print(\'Inside the context\')\\n","link":"https://docs.python.org/3/library/contextlib.html"},{"question":"Jakie są nowości w zarządzaniu wyjątkami w Pythonie 3.10?","answer":"Python 3.10 wprowadził bardziej precyzyjne komunikaty o błędach składniowych, a także możliwość grupowania wyjątków za pomocą nowej klasy ExceptionGroup.","code":"try:\\n    raise ExceptionGroup(\'multiple errors\', [ValueError(\'val\'), TypeError(\'type\')])\\nexcept ExceptionGroup as eg:\\n    for e in eg.exceptions:\\n        print(f\'Caught: {e}\')\\n# Output:\\n# Caught: val\\n# Caught: type\\n","link":"https://www.python.org/dev/peps/pep-0654/"},{"question":"Jak działają moduły i pakiety w Pythonie?","answer":"Moduły to pojedyncze pliki Python zawierające definicje i instrukcje, które można importować do innych modułów. Pakiety to katalogi zawierające moduły oraz plik __init__.py, pozwalający na ich grupowanie.","code":"# mymodule.py\\ndef greet(name):\\n    return f\'Hello, {name}!\'\\n\\n# main.py\\nimport mymodule\\nprint(mymodule.greet(\'World\'))\\n\\n# Pakiet: package/\\n#     __init__.py\\n#     module1.py\\n#     module2.py\\n","link":"https://docs.python.org/3/tutorial/modules.html"},{"question":"Co to są dataclasses i jak ich używać?","answer":"Dataclasses to dekorator i klasa bazowa wprowadzona w Pythonie 3.7, która automatycznie generuje metody specjalne, takie jak __init__() i __repr__() dla klas.","code":"from dataclasses import dataclass\\n@dataclass\\nclass MyDataClass:\\n    name: str\\n    age: int\\n\\nperson = MyDataClass(name=\'Alice\', age=30)\\nprint(person)\\n# Output: MyDataClass(name=\'Alice\', age=30)\\n","link":"https://docs.python.org/3/library/dataclasses.html"},{"question":"Jak działa mechanizm garbage collection w Pythonie?","answer":"Garbage collection zarządza pamięcią, automatycznie usuwając obiekty, które nie są już używane. Python używa licznika referencji oraz algorytmu wykrywania cykli.","code":"import gc\\nx = []\\nx.append(x)\\ndel x\\ngc.collect()\\n# Cyclic reference is cleaned up\\n","link":"https://docs.python.org/3/library/gc.html"},{"question":"Jakie są różnice między __new__ a __init__?","answer":"__new__ tworzy nową instancję klasy, a __init__ inicjalizuje już istniejącą instancję klasy. __new__ jest rzadziej używany i zazwyczaj nadpisywany w klasach dziedziczących po immutable types jak tuple.","code":"class MyClass:\\n    def __new__(cls, *args, **kwargs):\\n        instance = super().__new__(cls)\\n        return instance\\n\\n    def __init__(self, value):\\n        self.value = value\\n\\nobj = MyClass(10)\\nprint(obj.value)\\n# Output: 10\\n","link":"https://docs.python.org/3/reference/datamodel.html#object.__new__"},{"question":"Co to są async i await i jak działają w Pythonie?","answer":"Async i await są używane do deklarowania i wykonywania funkcji asynchronicznych, pozwalając na wykonywanie innych zadań w czasie oczekiwania na wynik operacji I/O.","code":"import asyncio\\n\\nasync def fetch_data():\\n    await asyncio.sleep(1)\\n    return \'Data received\'\\n\\nasync def main():\\n    data = await fetch_data()\\n    print(data)\\n\\nasyncio.run(main())\\n# Output: Data received\\n","link":"https://docs.python.org/3/library/asyncio.html"},{"question":"Jakie są nowości w module typing w Pythonie 3.9 i 3.10?","answer":"Python 3.9 wprowadził proste typy unii (X | Y zamiast Union[X, Y]), a 3.10 wprowadził typy dokładnych protokołów (precise types) i lepsze wsparcie dla stałych literalnych (literal types).","code":"from typing import Union\\n\\n# Python 3.9+\\ndef foo(x: int | str) -> None:\\n    print(x)\\n\\nfoo(1)\\nfoo(\'bar\')\\n# Output: 1\\n# Output: bar\\n","link":"https://docs.python.org/3/library/typing.html"},{"question":"Czym różnią się funkcje wbudowane map, filter i reduce?","answer":"Map stosuje funkcję do każdego elementu w iterowalnym obiekcie. Filter filtruje elementy zgodnie z funkcją warunkową. Reduce stosuje funkcję kumulatywną do par elementów, redukując je do jednej wartości.","code":"def square(x):\\n    return x * x\\n\\nresult = map(square, [1, 2, 3, 4])\\nprint(list(result))\\n# Output: [1, 4, 9, 16]\\n\\ndef is_even(x):\\n    return x % 2 == 0\\n\\nresult = filter(is_even, [1, 2, 3, 4])\\nprint(list(result))\\n# Output: [2, 4]\\n\\nfrom functools import reduce\\n\\ndef add(x, y):\\n    return x + y\\n\\nresult = reduce(add, [1, 2, 3, 4])\\nprint(result)\\n# Output: 10\\n","link":"https://docs.python.org/3/library/functions.html#map"},{"question":"Jakie są różnice między staticmethod a classmethod?","answer":"Staticmethod to metoda, która nie przyjmuje żadnych dodatkowych argumentów (takich jak self lub cls), podczas gdy classmethod przyjmuje klasę jako pierwszy argument (cls).","code":"class MyClass:\\n    @staticmethod\\n    def static_method():\\n        print(\'This is a static method\')\\n\\nMyClass.static_method()\\n# Output: This is a static method\\n\\nclass MyClass:\\n    @classmethod\\n    def class_method(cls):\\n        print(\'This is a class method\')\\n\\nMyClass.class_method()\\n# Output: This is a class method\\n","link":"https://docs.python.org/3/library/functions.html#staticmethod"},{"question":"Jak działa PEP 572 (Assignment Expressions)?","answer":"PEP 572 wprowadza operator przypisania wyrażeniowego :=, znany również jako \'walrus operator\', który pozwala na przypisanie wartości w ramach wyrażenia.","code":"if (n := len([1, 2, 3, 4, 5])) > 3:\\n    print(f\'List is too long ({n} elements)\')\\n# Output: List is too long (5 elements)\\n","link":"https://www.python.org/dev/peps/pep-0572/"},{"question":"Co to są f-strings i jak działają?","answer":"F-strings to sposób formatowania łańcuchów znaków wprowadzony w Pythonie 3.6, który pozwala na bezpośrednie wstawianie wyrażeń wewnątrz łańcuchów za pomocą nawiasów klamrowych, np. f\\"{variable}\\".","code":"name = \'Alice\'\\nage = 30\\nprint(f\'My name is {name} and I am {age} years old.\')\\n# Output: My name is Alice and I am 30 years old.\\n","link":"https://docs.python.org/3/reference/lexical_analysis.html#f-strings"},{"question":"Jak działają namedtuples i jakie są ich zalety?","answer":"Namedtuples to rozszerzenie klasy tuple, które pozwala na dostęp do elementów za pomocą nazwanych atrybutów. Zaletą jest czytelniejszy kod oraz dostępność elementów zarówno przez indeks, jak i przez nazwę.","code":"from collections import namedtuple\\n\\nPoint = namedtuple(\'Point\', [\'x\', \'y\'])\\np = Point(11, y=22)\\nprint(p.x, p.y)\\n# Output: 11 22\\n","link":"https://docs.python.org/3/library/collections.html#collections.namedtuple"},{"question":"Czym jest __slots__ i kiedy warto go używać?","answer":"__slots__ to mechanizm w Pythonie, który ogranicza atrybuty instancji do określonej listy, co może prowadzić do oszczędności pamięci i przyspieszenia dostępu do atrybutów.","code":"class MyClass:\\n    __slots__ = [\'name\', \'age\']\\n\\n    def __init__(self, name, age):\\n        self.name = name\\n        self.age = age\\n\\nobj = MyClass(\'Alice\', 30)\\n# obj.__dict__ will raise AttributeError\\n","link":"https://docs.python.org/3/reference/datamodel.html#slots"},{"question":"Jak działa contextlib i jakich funkcji z tego modułu warto używać?","answer":"Contextlib to moduł dostarczający narzędzi do pracy z context managers. Warto używać funkcji contextmanager do tworzenia własnych menedżerów kontekstu oraz funkcji closing do zarządzania zasobami wymagającymi zamknięcia.","code":"from contextlib import contextmanager, closing\\nimport sqlite3\\n\\n@contextmanager\\ndef my_context_manager():\\n    print(\'Entering the context\')\\n    yield\\n    print(\'Exiting the context\')\\n\\nwith my_context_manager():\\n    print(\'Inside the context\')\\n\\nwith closing(sqlite3.connect(\':memory:\')) as db:\\n    pass\\n# db is automatically closed\\n","link":"https://docs.python.org/3/library/contextlib.html"},{"question":"Jakie są nowości w Django 3.2 i 4.0?","answer":"Django 3.2 wprowadził wsparcie dla nowych funkcji bazy danych, automatyczne ustawianie nazw tabel, ulepszone migracje i nowy dekorator @dbtransaction. Django 4.0 wprowadził async ORM, wsparcie dla nowych funkcji baz danych i uproszczenia w konfiguracji.","link":"https://docs.djangoproject.com/en/3.2/releases/3.2/"},{"question":"Jak działa system migracji w Django?","answer":"System migracji w Django pozwala na śledzenie zmian w modelach bazy danych i automatyczne aktualizowanie schematu bazy danych za pomocą poleceń makemigrations i migrate.","code":"python manage.py makemigrations\\npython manage.py migrate\\n","link":"https://docs.djangoproject.com/en/3.2/topics/migrations/"},{"question":"Czym różni się ModelForm od zwykłego Form w Django?","answer":"ModelForm automatycznie generuje pola formularza na podstawie modelu Django, upraszczając proces tworzenia formularzy związanych z modelami. Form jest ogólnym formularzem, który wymaga ręcznego definiowania pól.","code":"from django import forms\\nfrom .models import MyModel\\n\\nclass MyModelForm(forms.ModelForm):\\n    class Meta:\\n        model = MyModel\\n        fields = [\'field1\', \'field2\']\\n","link":"https://docs.djangoproject.com/en/3.2/topics/forms/modelforms/"},{"question":"Jak działają klasy CBV (Class Based Views) w Django?","answer":"Class Based Views w Django umożliwiają tworzenie widoków jako klas, co pozwala na wykorzystanie dziedziczenia i ponowne użycie kodu. CBV oferują większą modularność i elastyczność niż funkcje widoków.","code":"from django.views import View\\nfrom django.http import HttpResponse\\n\\nclass MyView(View):\\n    def get(self, request):\\n        return HttpResponse(\'Hello, world!\')\\n","link":"https://docs.djangoproject.com/en/3.2/topics/class-based-views/"},{"question":"Jak zaimplementować niestandardowy menedżer modelu (Manager) w Django?","answer":"Aby zaimplementować niestandardowy menedżer, należy stworzyć klasę dziedziczącą po models.Manager i zdefiniować niestandardowe metody zarządzania zapytaniami. Następnie przypisać ten menedżer do modelu.","code":"from django.db import models\\n\\nclass MyManager(models.Manager):\\n    def get_queryset(self):\\n        return super().get_queryset().filter(is_active=True)\\n\\nclass MyModel(models.Model):\\n    name = models.CharField(max_length=100)\\n    is_active = models.BooleanField(default=True)\\n    objects = MyManager()\\n","link":"https://docs.djangoproject.com/en/3.2/topics/db/managers/"},{"question":"Jak działa mechanizm sesji w Django?","answer":"Mechanizm sesji w Django pozwala na przechowywanie danych użytkownika między żądaniami HTTP. Sesje są identyfikowane za pomocą unikalnych kluczy sesji i mogą być przechowywane w różnych backendach, takich jak baza danych, cache, lub pliki.","code":"# settings.py\\nSESSION_ENGINE = \'django.contrib.sessions.backends.cache\'\\n","link":"https://docs.djangoproject.com/en/3.2/topics/http/sessions/"},{"question":"Czym są sygnały w Django i jak ich używać?","answer":"Sygnały w Django to mechanizm pozwalający na powiadamianie różnych części aplikacji o wystąpieniu zdarzeń. Używa się ich za pomocą dispatcher.connect() do rejestrowania odbiorników i sygnałów zdefiniowanych w django.dispatch.","code":"from django.db.models.signals import post_save\\nfrom django.dispatch import receiver\\nfrom .models import MyModel\\n\\n@receiver(post_save, sender=MyModel)\\ndef my_handler(sender, instance, created, **kwargs):\\n    if created:\\n        print(\'New instance created\')\\n","link":"https://docs.djangoproject.com/en/3.2/topics/signals/"},{"question":"Jak zaimplementować relacje ManyToMany w Django?","answer":"Relacje ManyToMany w Django są definiowane za pomocą pola models.ManyToManyField. Można je zdefiniować bezpośrednio w modelu lub za pomocą dodatkowej tabeli łączącej (through).","code":"class Person(models.Model):\\n    name = models.CharField(max_length=100)\\n\\nclass Group(models.Model):\\n    name = models.CharField(max_length=100)\\n    members = models.ManyToManyField(Person, related_name=\'groups\')\\n","link":"https://docs.djangoproject.com/en/3.2/ref/models/fields/#django.db.models.ManyToManyField"},{"question":"Jak działa mechanizm cache\'owania w Django?","answer":"Mechanizm cache\'owania w Django pozwala na przechowywanie wyników drogich operacji w pamięci, co przyspiesza działanie aplikacji. Django wspiera różne backendy cache\'owania, takie jak Memcached, Redis, i lokalna pamięć.","code":"# settings.py\\nCACHES = {\\n    \'default\': {\\n        \'BACKEND\': \'django.core.cache.backends.memcached.MemcachedCache\',\\n        \'LOCATION\': \'127.0.0.1:11211\',\\n    }\\n}\\n","link":"https://docs.djangoproject.com/en/3.2/topics/cache/"},{"question":"Jak konfigurować i używać middleware w Django?","answer":"Middleware to komponenty, które przetwarzają żądania i odpowiedzi na różnych etapach cyklu życia żądania HTTP. Konfiguracja odbywa się poprzez dodanie klas middleware do listy MIDDLEWARE w pliku settings.py.","code":"# settings.py\\nMIDDLEWARE = [\\n    \'django.middleware.security.SecurityMiddleware\',\\n    \'django.contrib.sessions.middleware.SessionMiddleware\',\\n    \'django.middleware.common.CommonMiddleware\',\\n    \'django.middleware.csrf.CsrfViewMiddleware\',\\n    \'django.contrib.auth.middleware.AuthenticationMiddleware\',\\n    \'django.contrib.messages.middleware.MessageMiddleware\',\\n    \'django.middleware.clickjacking.XFrameOptionsMiddleware\',\\n]\\n","link":"https://docs.djangoproject.com/en/3.2/topics/http/middleware/"},{"question":"Jak działa admin w Django i jak można go rozszerzać?","answer":"Django admin to interfejs do zarządzania modelami aplikacji. Można go rozszerzać poprzez rejestrację modeli i niestandardowych klas admin.ModelAdmin, które definiują wygląd i zachowanie interfejsu administracyjnego.","code":"from django.contrib import admin\\nfrom .models import MyModel\\n\\nclass MyModelAdmin(admin.ModelAdmin):\\n    list_display = (\'name\', \'created_at\')\\n    search_fields = (\'name\',)\\n\\nadmin.site.register(MyModel, MyModelAdmin)\\n","link":"https://docs.djangoproject.com/en/3.2/ref/contrib/admin/"},{"question":"Jak zorganizować statyczne pliki i pliki multimedialne w Django?","answer":"Statyczne pliki są przechowywane w katalogach określonych w STATICFILES_DIRS i udostępniane przez serwer plików statycznych. Pliki multimedialne są przechowywane w katalogu MEDIA_ROOT i dostępne przez MEDIA_URL.","code":"# settings.py\\nSTATIC_URL = \'/static/\'\\nSTATICFILES_DIRS = [BASE_DIR / \'static\']\\nMEDIA_URL = \'/media/\'\\nMEDIA_ROOT = BASE_DIR / \'media\'\\n","link":"https://docs.djangoproject.com/en/3.2/howto/static-files/"},{"question":"Jak działa routing w Django i jak definiować niestandardowe URL?","answer":"Routing w Django polega na mapowaniu URL na widoki za pomocą wzorców URL definiowanych w pliku urls.py. Niestandardowe URL można definiować za pomocą wyrażeń regularnych lub funkcji path() i re_path().","code":"from django.urls import path\\nfrom . import views\\n\\nurlpatterns = [\\n    path(\'\', views.index, name=\'index\'),\\n    path(\'detail/<int:id>/\', views.detail, name=\'detail\'),\\n]\\n","link":"https://docs.djangoproject.com/en/3.2/topics/http/urls/"},{"question":"Czym są testy jednostkowe i integracyjne w Django?","answer":"Testy jednostkowe sprawdzają pojedyncze komponenty aplikacji, a testy integracyjne sprawdzają współdziałanie różnych komponentów. Django dostarcza narzędzia do tworzenia obu rodzajów testów w ramach modułu django.test.","code":"from django.test import TestCase\\nfrom .models import MyModel\\n\\nclass MyModelTest(TestCase):\\n    def test_string_representation(self):\\n        instance = MyModel(name=\'test\')\\n        self.assertEqual(str(instance), \'test\')\\n","link":"https://docs.djangoproject.com/en/3.2/topics/testing/"},{"question":"Jak działa ORM w Django i jak pisać złożone zapytania?","answer":"ORM w Django pozwala na interakcję z bazą danych za pomocą modeli Pythona. Złożone zapytania można pisać, używając metod querysets, takich jak filter(), exclude(), annotate(), aggregate(), oraz Q objects do zapytań warunkowych.","code":"from django.db.models import Q\\n\\n# Zapytanie złożone z użyciem Q objects\\nresults = MyModel.objects.filter(Q(name__startswith=\'A\') & Q(age__gte=30))\\n","link":"https://docs.djangoproject.com/en/3.2/topics/db/queries/"},{"question":"Jak zabezpieczyć aplikację Django przed atakami CSRF i XSS?","answer":"Django ma wbudowane mechanizmy ochrony przed CSRF (Cross-Site Request Forgery) za pomocą tokenów CSRF oraz ochrony przed XSS (Cross-Site Scripting) poprzez automatyczne escapowanie danych w szablonach.","code":"<form method=\\"post\\">\\n    {% csrf_token %}\\n    \x3c!-- other form fields --\x3e\\n</form>\\n","link":"https://docs.djangoproject.com/en/3.2/topics/security/"},{"question":"Jak konfigurować i korzystać z narzędzi CI/CD z Django?","answer":"Narzędzia CI/CD, takie jak Jenkins, GitLab CI/CD, lub GitHub Actions, mogą być używane do automatyzacji testowania i wdrażania aplikacji Django. Konfiguracja polega na stworzeniu skryptów build, test i deploy.","code":"name: Django CI\\n\\non: [push]\\n\\njobs:\\n  build:\\n    runs-on: ubuntu-latest\\n    steps:\\n    - uses: actions/checkout@v2\\n    - name: Set up Python\\n      uses: actions/setup-python@v2\\n      with:\\n        python-version: 3.8\\n    - name: Install dependencies\\n      run: |\\n        python -m pip install --upgrade pip\\n        pip install -r requirements.txt\\n    - name: Run tests\\n      run: |\\n        python manage.py test\\n","link":"https://docs.github.com/en/actions"},{"question":"Jakie są zalety używania Django Rest Framework (DRF)?","answer":"DRF oferuje uproszczone tworzenie API, zapewniając narzędzia do serializacji danych, autoryzacji, paginacji i automatycznego generowania endpointów API. Ułatwia również tworzenie testów i dokumentacji API.","code":"from rest_framework import serializers\\nfrom .models import MyModel\\n\\nclass MyModelSerializer(serializers.ModelSerializer):\\n    class Meta:\\n        model = MyModel\\n        fields = [\'id\', \'name\', \'age\']\\n","link":"https://www.django-rest-framework.org/"},{"question":"Jak działa mechanizm tłumaczeń (i18n) w Django?","answer":"Mechanizm i18n w Django pozwala na tłumaczenie aplikacji na różne języki za pomocą plików .po i .mo. Używa się funkcji gettext do oznaczania tekstów do tłumaczenia oraz narzędzi takich jak makemessages i compilemessages do zarządzania tłumaczeniami.","code":"from django.utils.translation import gettext as _\\n\\n# Przykład tłumaczenia\\noutput = _(\'Hello, world!\')\\n","link":"https://docs.djangoproject.com/en/3.2/topics/i18n/translation/"},{"question":"Jakie są najlepsze praktyki w deployowaniu aplikacji Django na produkcję?","answer":"Najlepsze praktyki obejmują używanie serwera WSGI, takiego jak Gunicorn, serwera proxy, takiego jak Nginx, konfigurowanie baz danych, używanie systemów cache, jak Redis, ustawianie zmiennych środowiskowych, oraz monitorowanie i logowanie aplikacji.","code":"# Gunicorn\\n$ gunicorn myproject.wsgi:application --bind 0.0.0.0:8000\\n\\n# Nginx\\nserver {\\n    listen 80;\\n    server_name example.com;\\n\\n    location = /favicon.ico { access_log off; log_not_found off; }\\n    location /static/ {\\n        root /path/to/static/files;\\n    }\\n\\n    location / {\\n        include proxy_params;\\n        proxy_pass http://unix:/path/to/your/mysite/mysite.sock;\\n    }\\n}\\n","link":"https://docs.djangoproject.com/en/3.2/howto/deployment/checklist/"},{"question":"Zdefiniuj relację jeden do jednego między modelem User a modelem Profile w Django.","answer":"Relacja jeden do jednego pozwala na powiązanie jednej instancji modelu z dokładnie jedną instancją innego modelu. W Django można to osiągnąć za pomocą pola OneToOneField.","code":"from django.db import models\\nfrom django.contrib.auth.models import User\\n\\nclass Profile(models.Model):\\n    user = models.OneToOneField(User, on_delete=models.CASCADE)\\n    bio = models.TextField()\\n"},{"question":"Utwórz relację wiele do wielu między modelem Category a modelem Product.","answer":"Relacja wiele do wielu pozwala na powiązanie wielu instancji jednego modelu z wieloma instancjami innego modelu. W Django można to osiągnąć za pomocą pola ManyToManyField.","code":"class Category(models.Model):\\n    name = models.CharField(max_length=100)\\n\\nclass Product(models.Model):\\n    name = models.CharField(max_length=100)\\n    categories = models.ManyToManyField(Category)\\n"},{"question":"Dodaj stronę w aplikacji Django, która wyświetla wszystkie pracownice firmy.","answer":"Aby dodać stronę wyświetlającą wszystkie pracownice firmy, należy utworzyć widok, który pobiera odpowiednie dane z bazy i renderuje je za pomocą szablonu.","code":"from django.shortcuts import render\\nfrom .models import Employee\\n\\ndef female_employees(request):\\n    females = Employee.objects.filter(sex=\'F\')\\n    return render(request, \'female_employees.html\', {\'employees\': females})\\n"},{"question":"Ulepsz funkcję wyszukiwania w Django, aby zwracała pracowników pasujących do podanej nazwy.","answer":"Aby ulepszyć funkcję wyszukiwania, należy dodać możliwość filtrowania pracowników na podstawie podanej nazwy, korzystając z zapytania GET.","code":"from django.shortcuts import render\\nfrom .models import Employee\\n\\ndef search_employees(request):\\n    query = request.GET.get(\'q\')\\n    if query:\\n        employees = Employee.objects.filter(name__icontains=query)\\n    else:\\n        employees = Employee.objects.all()\\n    return render(request, \'employee_list.html\', {\'employees\': employees})\\n"},{"question":"Co to jest Python i jakie są jego główne zalety?","answer":"Python to interpretowany, wysokopoziomowy język programowania ogólnego przeznaczenia. Jego główne zalety to czytelność kodu, duża liczba bibliotek i frameworków, wsparcie dla różnych paradygmatów programowania (np. obiektowego, funkcyjnego), oraz duża społeczność użytkowników.","code":"","link":"https://www.python.org/doc/essays/blurb/"},{"question":"Jakie są różnice między Python 2 a Python 3?","answer":"Python 3 wprowadził wiele zmian w stosunku do Python 2, w tym: print jako funkcja, nowe podejście do obsługi napisów (str i bytes), uproszczona składnia dla division, usunięcie wielu przestarzałych funkcji i modułów, oraz poprawki związane z obsługą wyjątków i importów.","code":"print(\'Hello, World!\')  # Python 3\\nprint \'Hello, World!\'  # Python 2 (SyntaxError in Python 3)","link":"https://wiki.python.org/moin/Python2orPython3"},{"question":"Wymień kilka podstawowych typów danych w Pythonie.","answer":"Podstawowe typy danych w Pythonie to: int (liczby całkowite), float (liczby zmiennoprzecinkowe), str (napisy), bool (wartości logiczne), list (listy), tuple (krotki), dict (słowniki) i set (zbiory).","code":"x = 10  # int\\npi = 3.14  # float\\nname = \'Python\'  # str\\nis_valid = True  # bool\\nnumbers = [1, 2, 3]  # list\\npoint = (1, 2)  # tuple\\ndetails = {\'name\': \'Python\', \'version\': 3.8}  # dict\\nunique_numbers = {1, 2, 3}  # set","link":"https://docs.python.org/3/library/stdtypes.html"},{"question":"Co to są listy, tupele i słowniki w Pythonie?","answer":"Listy to zmienne sekwencje przechowujące kolekcje obiektów. Tupele to niemutowalne sekwencje przechowujące kolekcje obiektów. Słowniki to struktury danych przechowujące pary klucz-wartość, gdzie klucze muszą być unikalne.","code":"my_list = [1, 2, 3]\\nmy_tuple = (1, 2, 3)\\nmy_dict = {\'key1\': \'value1\', \'key2\': \'value2\'}","link":"https://docs.python.org/3/tutorial/datastructures.html"},{"question":"Jakie są różnice między listą a tuplą?","answer":"Listy są mutowalne, co oznacza, że można je modyfikować po stworzeniu, natomiast tupele są niemutowalne i nie można zmieniać ich zawartości po stworzeniu. Listy używają nawiasów kwadratowych, a tupele nawiasów okrągłych.","code":"my_list = [1, 2, 3]\\nmy_list.append(4)  # my_list: [1, 2, 3, 4]\\n\\nmy_tuple = (1, 2, 3)\\n# my_tuple.append(4)  # AttributeError: \'tuple\' object has no attribute \'append\'","link":"https://docs.python.org/3/tutorial/datastructures.html#more-on-lists"},{"question":"Co to jest „list comprehension” w Pythonie?","answer":"List comprehension to zwięzła metoda tworzenia listy na podstawie istniejącej iteracji, pozwalająca na stosowanie wyrażeń i filtrów w jednej linii kodu.","code":"squares = [x**2 for x in range(10)]  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]","link":"https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions"},{"question":"Jak działają słowniki w Pythonie?","answer":"Słowniki w Pythonie to struktury danych przechowujące pary klucz-wartość. Klucze muszą być unikalne i niemutowalne, natomiast wartości mogą być dowolnego typu.","code":"my_dict = {\'name\': \'Alice\', \'age\': 30}\\nprint(my_dict[\'name\'])  # Output: Alice\\nmy_dict[\'age\'] = 31\\nprint(my_dict)  # Output: {\'name\': \'Alice\', \'age\': 31}","link":"https://docs.python.org/3/tutorial/datastructures.html#dictionaries"},{"question":"Co to jest funkcja lambda w Pythonie?","answer":"Funkcja lambda to anonimowa funkcja definiowana za pomocą słowa kluczowego lambda, umożliwiająca szybkie tworzenie małych funkcji bez nazwy.","code":"add = lambda x, y: x + y\\nprint(add(2, 3))  # Output: 5","link":"https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions"},{"question":"Jak działa zarządzanie pamięcią w Pythonie?","answer":"Python zarządza pamięcią automatycznie przy użyciu mechanizmu garbage collection oraz liczników referencji. Obiekty są tworzone i usuwane z pamięci automatycznie, gdy nie są już potrzebne.","code":"","link":"https://docs.python.org/3/library/gc.html"},{"question":"Co to jest garbage collection w Pythonie?","answer":"Garbage collection w Pythonie to mechanizm zarządzania pamięcią, który automatycznie usuwa obiekty, które nie są już używane. Python używa licznika referencji oraz algorytmu wykrywania cykli.","code":"import gc\\nx = []\\nx.append(x)\\ndel x\\ngc.collect()  # Cyclic reference is cleaned up","link":"https://docs.python.org/3/library/gc.html"},{"question":"Jakie są sposoby obsługi wyjątków w Pythonie?","answer":"Python obsługuje wyjątki za pomocą bloków try-except. Można również używać bloków finally do wykonania kodu, który musi się wykonać niezależnie od tego, czy wyjątek wystąpił, oraz bloków else, które wykonują kod, gdy wyjątek nie wystąpił.","code":"try:\\n    x = 1 / 0\\nexcept ZeroDivisionError:\\n    print(\'Nie można dzielić przez zero\')\\nelse:\\n    print(\'Kod wykonany, jeśli nie ma wyjątku\')\\nfinally:\\n    print(\'Kod wykonany niezależnie od tego, czy wyjątek wystąpił\')","link":"https://docs.python.org/3/tutorial/errors.html"},{"question":"Co to jest „decorator” w Pythonie?","answer":"Dekorator to funkcja, która przyjmuje inną funkcję jako argument, rozszerzając jej funkcjonalność bez zmiany jej kodu. Dekoratory są często używane do logowania, kontroli dostępu, modyfikacji funkcji itp.","code":"def my_decorator(func):\\n    def wrapper():\\n        print(\'Coś przed funkcją\')\\n        func()\\n        print(\'Coś po funkcji\')\\n    return wrapper\\n\\n@my_decorator\\ndef say_hello():\\n    print(\'Hello!\')\\n\\nsay_hello()\\n# Output:\\n# Coś przed funkcją\\n# Hello!\\n# Coś po funkcji","link":"https://realpython.com/primer-on-python-decorators/"},{"question":"Jakie są różnice między metodą statyczną a metodą klasy w Pythonie?","answer":"Metoda statyczna (@staticmethod) to metoda, która nie przyjmuje żadnych dodatkowych argumentów (takich jak self lub cls). Metoda klasy (@classmethod) przyjmuje klasę jako pierwszy argument (cls) i może modyfikować stan klasy.","code":"class MyClass:\\n    @staticmethod\\n    def static_method():\\n        print(\'To jest metoda statyczna\')\\n\\n    @classmethod\\n    def class_method(cls):\\n        print(\'To jest metoda klasy\')\\n\\nMyClass.static_method()\\n# Output: To jest metoda statyczna\\nMyClass.class_method()\\n# Output: To jest metoda klasy","link":"https://docs.python.org/3/library/functions.html#staticmethod"},{"question":"Jak działają generatory w Pythonie?","answer":"Generatory to specjalne funkcje, które zwracają obiekt generatora. Używają słowa kluczowego yield do zwracania wartości i zapamiętują stan funkcji, dzięki czemu mogą kontynuować od miejsca, w którym przerwały.","code":"def my_generator():\\n    yield 1\\n    yield 2\\n    yield 3\\n\\ngen = my_generator()\\nprint(next(gen))  # Output: 1\\nprint(next(gen))  # Output: 2\\nprint(next(gen))  # Output: 3","link":"https://docs.python.org/3/tutorial/classes.html#generators"},{"question":"Co to jest „context manager” i do czego służy w Pythonie?","answer":"Context manager to obiekt, który zarządza zasobami w kontekście wyrażenia with. Umożliwia bezpieczne zarządzanie zasobami, takimi jak otwieranie i zamykanie plików.","code":"with open(\'file.txt\', \'r\') as file:\\n    data = file.read()\\n# File is automatically closed after the block","link":"https://docs.python.org/3/library/contextlib.html"},{"question":"Jak zaimplementować „context manager” przy użyciu słowa kluczowego with?","answer":"Context manager można zaimplementować za pomocą metod __enter__ i __exit__, lub za pomocą dekoratora @contextmanager z modułu contextlib.","code":"class MyContextManager:\\n    def __enter__(self):\\n        print(\'Wchodzenie do kontekstu\')\\n        return self\\n    def __exit__(self, exc_type, exc_value, traceback):\\n        print(\'Opuszczanie kontekstu\')\\n\\nwith MyContextManager() as manager:\\n    print(\'Wewnątrz kontekstu\')\\n\\nfrom contextlib import contextmanager\\n\\n@contextmanager\\ndef my_context_manager():\\n    print(\'Wchodzenie do kontekstu\')\\n    yield\\n    print(\'Opuszczanie kontekstu\')\\n\\nwith my_context_manager():\\n    print(\'Wewnątrz kontekstu\')","link":"https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager"},{"question":"Jak działają moduły i pakiety w Pythonie?","answer":"Moduły to pojedyncze pliki Python zawierające definicje i instrukcje, które można importować do innych modułów. Pakiety to katalogi zawierające moduły oraz plik __init__.py, pozwalający na ich grupowanie.","code":"# mymodule.py\\ndef greet(name):\\n    return f\'Hello, {name}!\'\\n\\n# main.py\\nimport mymodule\\nprint(mymodule.greet(\'World\'))\\n\\n# Pakiet: package/\\n#     __init__.py\\n#     module1.py\\n#     module2.py\\n","link":"https://docs.python.org/3/tutorial/modules.html"},{"question":"Co to jest PEP 8 i dlaczego jest ważne?","answer":"PEP 8 to dokument określający konwencje kodowania w Pythonie, mający na celu poprawę czytelności i spójności kodu. Przestrzeganie PEP 8 ułatwia współpracę między programistami oraz utrzymanie i rozwój kodu.","code":"","link":"https://pep8.org/"},{"question":"Jak zainstalować i zarządzać pakietami w Pythonie?","answer":"Pakiety w Pythonie instaluje się i zarządza za pomocą narzędzia pip. Używając pip, można instalować, aktualizować i usuwać pakiety.","code":"# Install a package\\npip install package_name\\n\\n# Upgrade a package\\npip install --upgrade package_name\\n\\n# Uninstall a package\\npip uninstall package_name","link":"https://pip.pypa.io/en/stable/"},{"question":"Co to jest pip i jak go używać?","answer":"Pip to menedżer pakietów dla Pythona, używany do instalacji i zarządzania pakietami Pythonowymi. Pozwala na łatwe instalowanie, aktualizowanie i usuwanie pakietów.","code":"# Install a package\\npip install package_name\\n\\n# Upgrade a package\\npip install --upgrade package_name\\n\\n# Uninstall a package\\npip uninstall package_name","link":"https://pip.pypa.io/en/stable/"},{"question":"Co to jest virtualenv i do czego służy?","answer":"Virtualenv to narzędzie do tworzenia izolowanych środowisk Pythonowych. Pozwala na stworzenie środowiska z własnym zbiorem zainstalowanych pakietów, co umożliwia pracę nad różnymi projektami z różnymi zależnościami bez konfliktów.","code":"# Create a virtual environment\\nvirtualenv venv\\n\\n# Activate the virtual environment\\nsource venv/bin/activate  # On Windows use: venv\\\\Scripts\\\\activate\\n\\n# Deactivate the virtual environment\\ndeactivate","link":"https://virtualenv.pypa.io/en/stable/"},{"question":"Jakie są różnice między virtualenv a venv?","answer":"Virtualenv i venv są narzędziami do tworzenia izolowanych środowisk Pythonowych, jednak virtualenv jest zewnętrznym narzędziem, które działa z Python 2 i 3, podczas gdy venv jest wbudowanym modułem dostępnym od Pythona 3.3.","code":"","link":"https://docs.python.org/3/library/venv.html"},{"question":"Co to jest __init__.py?","answer":"__init__.py to plik, który jest umieszczany w katalogu, aby Python traktował go jako pakiet. Plik ten może być pusty lub zawierać kod inicjalizacyjny dla pakietu.","code":"","link":"https://docs.python.org/3/tutorial/modules.html#packages"},{"question":"Jakie są różnice między __str__ a __repr__ w Pythonie?","answer":"__str__ zwraca \'ładną\' reprezentację łańcuchową obiektu, przeznaczoną dla użytkownika końcowego. __repr__ zwraca bardziej szczegółową reprezentację, która powinna być jednoznaczna i, jeśli to możliwe, umożliwia stworzenie obiektu na podstawie zwróconego łańcucha.","code":"class MyClass:\\n    def __str__(self):\\n        return \'To jest str\'\\n    def __repr__(self):\\n        return \'To jest repr\'\\n\\nobj = MyClass()\\nprint(str(obj))  # Output: To jest str\\nprint(repr(obj))  # Output: To jest repr","link":"https://docs.python.org/3/reference/datamodel.html#object.__repr__"},{"question":"Co to jest __main__ w Pythonie?","answer":"__main__ to nazwa modułu, który jest uruchamiany jako główny program. Kiedy moduł jest uruchamiany bezpośrednio, wartość __name__ wynosi \'__main__\', co pozwala na uruchamianie kodu tylko wtedy, gdy moduł jest uruchamiany jako skrypt.","code":"if __name__ == \'__main__\':\\n    print(\'Moduł jest uruchamiany bezpośrednio\')","link":"https://docs.python.org/3/library/__main__.html"},{"question":"Jak działają moduły w Pythonie?","answer":"Moduły w Pythonie to pliki zawierające definicje funkcji, klas i zmiennych, które mogą być importowane do innych modułów. Pozwalają na organizowanie kodu w logiczne jednostki.","code":"# mymodule.py\\ndef greet(name):\\n    return f\'Hello, {name}!\'\\n\\n# main.py\\nimport mymodule\\nprint(mymodule.greet(\'World\'))","link":"https://docs.python.org/3/tutorial/modules.html"},{"question":"Jakie są różnice między deepcopy a copy w Pythonie?","answer":"Shallow copy (copy) kopiuje obiekt, ale nie kopiuje obiektów zagnieżdżonych. Deepcopy tworzy pełną kopię obiektu wraz z wszystkimi obiektami zagnieżdżonymi.","code":"import copy\\noriginal = [1, [2, 3], 4]\\nshallow = copy.copy(original)\\nshallow[1][0] = \'a\'\\n# original: [1, [\'a\', 3], 4]\\n\\ndeep = copy.deepcopy(original)\\ndeep[1][0] = \'a\'\\n# original: [1, [2, 3], 4]\\n# deep: [1, [\'a\', 3], 4]","link":"https://docs.python.org/3/library/copy.html"},{"question":"Co to jest GIL (Global Interpreter Lock) i jak wpływa na wielowątkowość w Pythonie?","answer":"GIL to globalny interpreter lock, który pozwala tylko jednemu wątkowi na wykonywanie kodu Python w jednym czasie. Ogranicza to wydajność programów wielowątkowych w Pythonie, ale można go obejść używając procesów zamiast wątków.","code":"","link":"https://docs.python.org/3/glossary.html#term-global-interpreter-lock"},{"question":"Jakie są różnice między threading a multiprocessing w Pythonie?","answer":"Threading wykorzystuje wątki, które działają w ramach jednego procesu, co ogranicza je przez GIL. Multiprocessing tworzy oddzielne procesy, które mogą działać równolegle na różnych rdzeniach CPU, omijając ograniczenia GIL.","code":"","link":"https://docs.python.org/3/library/threading.html"},{"question":"Co to jest asyncio i jak działa?","answer":"Asyncio to moduł w Pythonie do pisania programów asynchronicznych przy użyciu async i await. Pozwala na wykonywanie innych zadań w czasie oczekiwania na operacje I/O, poprawiając wydajność.","code":"import asyncio\\n\\nasync def fetch_data():\\n    await asyncio.sleep(1)\\n    return \'Data received\'\\n\\nasync def main():\\n    data = await fetch_data()\\n    print(data)\\n\\nasyncio.run(main())\\n# Output: Data received","link":"https://docs.python.org/3/library/asyncio.html"},{"question":"Jak używać async i await w Pythonie?","answer":"Async i await są używane do deklarowania i wykonywania funkcji asynchronicznych. Funkcje asynchroniczne są deklarowane z async def, a await jest używane do wstrzymywania wykonywania funkcji do czasu zakończenia operacji asynchronicznej.","code":"import asyncio\\n\\nasync def fetch_data():\\n    await asyncio.sleep(1)\\n    return \'Data received\'\\n\\nasync def main():\\n    data = await fetch_data()\\n    print(data)\\n\\nasyncio.run(main())\\n# Output: Data received","link":"https://docs.python.org/3/library/asyncio.html"},{"question":"Co to są dekoratory i jak działają w Pythonie?","answer":"Dekoratory to funkcje, które przyjmują inną funkcję jako argument i zwracają nową funkcję, która rozszerza oryginalną funkcjonalność bez zmiany jej kodu.","code":"def my_decorator(func):\\n    def wrapper():\\n        print(\'Coś przed funkcją\')\\n        func()\\n        print(\'Coś po funkcji\')\\n    return wrapper\\n\\n@my_decorator\\ndef say_hello():\\n    print(\'Hello!\')\\n\\nsay_hello()\\n# Output:\\n# Coś przed funkcją\\n# Hello!\\n# Coś po funkcji","link":"https://realpython.com/primer-on-python-decorators/"},{"question":"Jak zaimplementować iterator w Pythonie?","answer":"Aby zaimplementować iterator, należy zdefiniować klasę z metodami __iter__() i __next__(). Metoda __iter__() powinna zwracać obiekt iteratora, a metoda __next__() powinna zwracać kolejne wartości.","code":"class MyIterator:\\n    def __init__(self, data):\\n        self.data = data\\n        self.index = 0\\n    def __iter__(self):\\n        return self\\n    def __next__(self):\\n        if self.index < len(self.data):\\n            result = self.data[self.index]\\n            self.index += 1\\n            return result\\n        else:\\n            raise StopIteration\\n\\nmy_iter = MyIterator([1, 2, 3])\\nfor item in my_iter:\\n    print(item)\\n# Output: 1\\n# Output: 2\\n# Output: 3","link":"https://docs.python.org/3/tutorial/classes.html#iterators"},{"question":"Jak zaimplementować generator w Pythonie?","answer":"Generator można zaimplementować za pomocą funkcji używającej słowa kluczowego yield. Funkcja generatora zwraca obiekt generatora, który można iterować.","code":"def my_generator():\\n    yield 1\\n    yield 2\\n    yield 3\\n\\ngen = my_generator()\\nprint(next(gen))  # Output: 1\\nprint(next(gen))  # Output: 2\\nprint(next(gen))  # Output: 3","link":"https://docs.python.org/3/tutorial/classes.html#generators"},{"question":"Jak działa serializacja w Pythonie? Omów pickle i json.","answer":"Serializacja to proces zamiany obiektu w strumień bajtów, który można przechowywać lub przesyłać. Pickle to moduł do serializacji obiektów Python do formatu binarnego, a json to moduł do serializacji obiektów Python do formatu JSON.","code":"import pickle\\n\\n# Serializacja za pomocą pickle\\nwith open(\'data.pkl\', \'wb\') as file:\\n    pickle.dump({\'key\': \'value\'}, file)\\n\\n# Deserializacja za pomocą pickle\\nwith open(\'data.pkl\', \'rb\') as file:\\n    data = pickle.load(file)\\n    print(data)  # Output: {\'key\': \'value\'}\\n\\nimport json\\n\\n# Serializacja za pomocą json\\njson_data = json.dumps({\'key\': \'value\'})\\nprint(json_data)  # Output: \'{\\"key\\": \\"value\\"}\'\\n\\n# Deserializacja za pomocą json\\ndata = json.loads(json_data)\\nprint(data)  # Output: {\'key\': \'value\'}","link":"https://docs.python.org/3/library/pickle.html"},{"question":"Jak działa dziedziczenie w Pythonie?","answer":"Dziedziczenie pozwala na tworzenie nowych klas na podstawie istniejących, dziedzicząc ich atrybuty i metody. Python obsługuje dziedziczenie pojedyncze i wielokrotne.","code":"class Parent:\\n    def greet(self):\\n        print(\'Hello from Parent\')\\n\\nclass Child(Parent):\\n    def greet(self):\\n        print(\'Hello from Child\')\\n\\nchild = Child()\\nchild.greet()  # Output: Hello from Child","link":"https://docs.python.org/3/tutorial/classes.html#inheritance"},{"question":"Co to jest wielodziedziczenie i jak Python sobie z nim radzi?","answer":"Wielodziedziczenie to możliwość dziedziczenia przez klasę z więcej niż jednej klasy bazowej. Python rozwiązuje konflikt metod za pomocą algorytmu MRO (Method Resolution Order).","code":"class Base1:\\n    def greet(self):\\n        print(\'Hello from Base1\')\\n\\nclass Base2:\\n    def greet(self):\\n        print(\'Hello from Base2\')\\n\\nclass Child(Base1, Base2):\\n    pass\\n\\nchild = Child()\\nchild.greet()  # Output: Hello from Base1 (because of MRO)","link":"https://docs.python.org/3/tutorial/classes.html#multiple-inheritance"},{"question":"Jakie są różnice między is a == w Pythonie?","answer":"Operator == sprawdza, czy wartości dwóch obiektów są równe, natomiast is sprawdza, czy dwie zmienne odnoszą się do tego samego obiektu w pamięci.","code":"a = [1, 2, 3]\\nb = [1, 2, 3]\\nc = a\\n\\nprint(a == b)  # Output: True\\nprint(a is b)  # Output: False\\nprint(a is c)  # Output: True","link":"https://docs.python.org/3/reference/expressions.html#is"},{"question":"Jak zaimplementować metodę w Pythonie, która jest bezpieczna wątkowo?","answer":"Aby zaimplementować metodę bezpieczną wątkowo, można użyć mechanizmów synchronizacji, takich jak blokady (locks) z modułu threading.","code":"import threading\\n\\nclass ThreadSafeCounter:\\n    def __init__(self):\\n        self.count = 0\\n        self.lock = threading.Lock()\\n\\n    def increment(self):\\n        with self.lock:\\n            self.count += 1\\n\\ncounter = ThreadSafeCounter()\\nthreads = [threading.Thread(target=counter.increment) for _ in range(1000)]\\nfor thread in threads:\\n    thread.start()\\nfor thread in threads:\\n    thread.join()\\nprint(counter.count)  # Output: 1000","link":"https://docs.python.org/3/library/threading.html#lock-objects"},{"question":"Jak zaimplementować metody magiczne (__magic_methods__) w Pythonie?","answer":"Metody magiczne to specjalne metody, które zaczynają i kończą się podwójnymi podkreśleniami. Pozwalają one na definiowanie niestandardowych zachowań dla operacji takich jak dodawanie, porównywanie, reprezentacja tekstowa itp.","code":"class MyClass:\\n    def __init__(self, value):\\n        self.value = value\\n\\n    def __str__(self):\\n        return f\'MyClass with value {self.value}\'\\n\\n    def __add__(self, other):\\n        return MyClass(self.value + other.value)\\n\\nobj1 = MyClass(10)\\nobj2 = MyClass(20)\\nobj3 = obj1 + obj2\\nprint(obj3)  # Output: MyClass with value 30","link":"https://docs.python.org/3/reference/datamodel.html#special-method-names"},{"question":"Co to jest Duck Typing?","answer":"Duck Typing to podejście do typowania, w którym typ obiektu jest określany na podstawie jego zachowania (metod i właściwości), a nie jego rzeczywistej klasy.","code":"class Duck:\\n    def quack(self):\\n        print(\'Quack\')\\n\\nclass Person:\\n    def quack(self):\\n        print(\'I can quack like a duck\')\\n\\ndef make_it_quack(thing):\\n    thing.quack()\\n\\nmake_it_quack(Duck())  # Output: Quack\\nmake_it_quack(Person())  # Output: I can quack like a duck","link":"https://realpython.com/lessons/duck-typing/"},{"question":"Jak działa operator in w Pythonie?","answer":"Operator in sprawdza, czy dany element znajduje się w sekwencji, takiej jak lista, tupla, zbiór lub słownik (dla kluczy).","code":"numbers = [1, 2, 3, 4, 5]\\nprint(3 in numbers)  # Output: True\\nprint(6 in numbers)  # Output: False","link":"https://docs.python.org/3/reference/expressions.html#membership-test-operations"},{"question":"Co to jest staticmethod i kiedy go używać?","answer":"Staticmethod to metoda, która nie przyjmuje żadnych dodatkowych argumentów (takich jak self lub cls). Używa się jej, gdy metoda nie potrzebuje dostępu do instancji ani do klasy.","code":"class MyClass:\\n    @staticmethod\\n    def static_method():\\n        print(\'To jest metoda statyczna\')\\n\\nMyClass.static_method()  # Output: To jest metoda statyczna","link":"https://docs.python.org/3/library/functions.html#staticmethod"},{"question":"Co to jest classmethod i kiedy go używać?","answer":"Classmethod to metoda, która przyjmuje klasę jako pierwszy argument (cls). Używa się jej, gdy metoda musi pracować z klasą, a nie z instancją.","code":"class MyClass:\\n    @classmethod\\n    def class_method(cls):\\n        print(\'To jest metoda klasy\')\\n\\nMyClass.class_method()  # Output: To jest metoda klasy","link":"https://docs.python.org/3/library/functions.html#classmethod"},{"question":"Jak działa dziedziczenie wielokrotne w Pythonie?","answer":"Dziedziczenie wielokrotne pozwala klasie dziedziczyć z więcej niż jednej klasy bazowej. Python rozwiązuje konflikty metod za pomocą algorytmu MRO (Method Resolution Order).","code":"class Base1:\\n    def greet(self):\\n        print(\'Hello from Base1\')\\n\\nclass Base2:\\n    def greet(self):\\n        print(\'Hello from Base2\')\\n\\nclass Child(Base1, Base2):\\n    pass\\n\\nchild = Child()\\nchild.greet()  # Output: Hello from Base1 (because of MRO)","link":"https://docs.python.org/3/tutorial/classes.html#multiple-inheritance"},{"question":"Jak zaimplementować własny moduł w Pythonie?","answer":"Własny moduł w Pythonie można zaimplementować tworząc plik z rozszerzeniem .py zawierający definicje funkcji, klas i zmiennych, które można importować do innych modułów.","code":"# mymodule.py\\ndef greet(name):\\n    return f\'Hello, {name}!\'\\n\\n# main.py\\nimport mymodule\\nprint(mymodule.greet(\'World\'))","link":"https://docs.python.org/3/tutorial/modules.html"},{"question":"Jakie są różnice między @staticmethod a @classmethod?","answer":"Staticmethod nie przyjmuje żadnych dodatkowych argumentów (takich jak self lub cls) i jest używana, gdy metoda nie potrzebuje dostępu do instancji ani do klasy. Classmethod przyjmuje klasę jako pierwszy argument (cls) i jest używana, gdy metoda musi pracować z klasą, a nie z instancją.","code":"class MyClass:\\n    @staticmethod\\n    def static_method():\\n        print(\'To jest metoda statyczna\')\\n\\n    @classmethod\\n    def class_method(cls):\\n        print(\'To jest metoda klasy\')\\n\\nMyClass.static_method()  # Output: To jest metoda statyczna\\nMyClass.class_method()  # Output: To jest metoda klasy","link":"https://docs.python.org/3/library/functions.html#staticmethod"},{"question":"Co to jest __new__ i jak różni się od __init__?","answer":"__new__ tworzy nową instancję klasy, a __init__ inicjalizuje już istniejącą instancję klasy. __new__ jest rzadziej używany i zazwyczaj nadpisywany w klasach dziedziczących po immutable types jak tuple.","code":"class MyClass:\\n    def __new__(cls, *args, **kwargs):\\n        instance = super().__new__(cls)\\n        return instance\\n\\n    def __init__(self, value):\\n        self.value = value\\n\\nobj = MyClass(10)\\nprint(obj.value)  # Output: 10","link":"https://docs.python.org/3/reference/datamodel.html#object.__new__"},{"question":"Jak działają metody magiczne __enter__ i __exit__?","answer":"Metody magiczne __enter__ i __exit__ są używane do zarządzania zasobami w kontekście wyrażenia with. __enter__ jest wywoływana na początku bloku with, a __exit__ na końcu bloku.","code":"class MyContextManager:\\n    def __enter__(self):\\n        print(\'Wchodzenie do kontekstu\')\\n        return self\\n    def __exit__(self, exc_type, exc_value, traceback):\\n        print(\'Opuszczanie kontekstu\')\\n\\nwith MyContextManager() as manager:\\n    print(\'Wewnątrz kontekstu\')","link":"https://docs.python.org/3/reference/datamodel.html#object.__enter__"},{"question":"Jakie są różnice między yield a return w Pythonie?","answer":"Yield zwraca wartość z funkcji generatora i zapamiętuje stan funkcji, aby kontynuować od tego punktu przy następnym wywołaniu. Return kończy wykonywanie funkcji i zwraca wartość.","code":"def my_generator():\\n    yield 1\\n    yield 2\\n    yield 3\\n\\ngen = my_generator()\\nprint(next(gen))  # Output: 1\\nprint(next(gen))  # Output: 2\\nprint(next(gen))  # Output: 3","link":"https://docs.python.org/3/tutorial/classes.html#generators"},{"question":"Co to jest Python i jakie są jego główne zalety?","answer":"Python to interpretowany, wysokopoziomowy język programowania ogólnego przeznaczenia. Jego główne zalety to czytelność kodu, duża liczba bibliotek i frameworków, wsparcie dla różnych paradygmatów programowania (np. obiektowego, funkcyjnego), oraz duża społeczność użytkowników.","code":"","link":"https://www.python.org/doc/essays/blurb/"},{"question":"Jakie są różnice między Python 2 a Python 3?","answer":"Python 3 wprowadził wiele zmian w stosunku do Python 2, w tym: print jako funkcja, nowe podejście do obsługi napisów (str i bytes), uproszczona składnia dla division, usunięcie wielu przestarzałych funkcji i modułów, oraz poprawki związane z obsługą wyjątków i importów.","code":"print(\'Hello, World!\')  # Python 3\\nprint \'Hello, World!\'  # Python 2 (SyntaxError in Python 3)","link":"https://wiki.python.org/moin/Python2orPython3"},{"question":"Wymień kilka podstawowych typów danych w Pythonie.","answer":"Podstawowe typy danych w Pythonie to: int (liczby całkowite), float (liczby zmiennoprzecinkowe), str (napisy), bool (wartości logiczne), list (listy), tuple (krotki), dict (słowniki) i set (zbiory).","code":"x = 10  # int\\npi = 3.14  # float\\nname = \'Python\'  # str\\nis_valid = True  # bool\\nnumbers = [1, 2, 3]  # list\\npoint = (1, 2)  # tuple\\ndetails = {\'name\': \'Python\', \'version\': 3.8}  # dict\\nunique_numbers = {1, 2, 3}  # set","link":"https://docs.python.org/3/library/stdtypes.html"},{"question":"Co to są listy, tupele i słowniki w Pythonie?","answer":"Listy to zmienne sekwencje przechowujące kolekcje obiektów. Tupele to niemutowalne sekwencje przechowujące kolekcje obiektów. Słowniki to struktury danych przechowujące pary klucz-wartość, gdzie klucze muszą być unikalne.","code":"my_list = [1, 2, 3]\\nmy_tuple = (1, 2, 3)\\nmy_dict = {\'key1\': \'value1\', \'key2\': \'value2\'}","link":"https://docs.python.org/3/tutorial/datastructures.html"},{"question":"Jakie są różnice między listą a tuplą?","answer":"Listy są mutowalne, co oznacza, że można je modyfikować po stworzeniu, natomiast tupele są niemutowalne i nie można zmieniać ich zawartości po stworzeniu. Listy używają nawiasów kwadratowych, a tupele nawiasów okrągłych.","code":"my_list = [1, 2, 3]\\nmy_list.append(4)  # my_list: [1, 2, 3, 4]\\n\\nmy_tuple = (1, 2, 3)\\n# my_tuple.append(4)  # AttributeError: \'tuple\' object has no attribute \'append\'","link":"https://docs.python.org/3/tutorial/datastructures.html#more-on-lists"},{"question":"Co to jest „list comprehension” w Pythonie?","answer":"List comprehension to zwięzła metoda tworzenia listy na podstawie istniejącej iteracji, pozwalająca na stosowanie wyrażeń i filtrów w jednej linii kodu.","code":"squares = [x**2 for x in range(10)]  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]","link":"https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions"},{"question":"Jak działają słowniki w Pythonie?","answer":"Słowniki w Pythonie to struktury danych przechowujące pary klucz-wartość. Klucze muszą być unikalne i niemutowalne, natomiast wartości mogą być dowolnego typu.","code":"my_dict = {\'name\': \'Alice\', \'age\': 30}\\nprint(my_dict[\'name\'])  # Output: Alice\\nmy_dict[\'age\'] = 31\\nprint(my_dict)  # Output: {\'name\': \'Alice\', \'age\': 31}","link":"https://docs.python.org/3/tutorial/datastructures.html#dictionaries"},{"question":"Co to jest funkcja lambda w Pythonie?","answer":"Funkcja lambda to anonimowa funkcja definiowana za pomocą słowa kluczowego lambda, umożliwiająca szybkie tworzenie małych funkcji bez nazwy.","code":"add = lambda x, y: x + y\\nprint(add(2, 3))  # Output: 5","link":"https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions"},{"question":"Jak działa zarządzanie pamięcią w Pythonie?","answer":"Python zarządza pamięcią automatycznie przy użyciu mechanizmu garbage collection oraz liczników referencji. Obiekty są tworzone i usuwane z pamięci automatycznie, gdy nie są już potrzebne.","code":"","link":"https://docs.python.org/3/library/gc.html"},{"question":"Co to jest garbage collection w Pythonie?","answer":"Garbage collection w Pythonie to mechanizm zarządzania pamięcią, który automatycznie usuwa obiekty, które nie są już używane. Python używa licznika referencji oraz algorytmu wykrywania cykli.","code":"import gc\\nx = []\\nx.append(x)\\ndel x\\ngc.collect()  # Cyclic reference is cleaned up","link":"https://docs.python.org/3/library/gc.html"}]'),G={name:"PythonView",components:{QuestionList:B},data(){return{questions:Q}}};const X=(0,c.A)(G,[["render",b],["__scopeId","data-v-d68874ee"]]);var K=X;const Z=e=>((0,t.Qi)("data-v-0eb592fa"),e=e(),(0,t.jt)(),e),$=Z((()=>(0,t.Lk)("h1",null,"JavaScript FAQ",-1)));function Y(e,n,a,o,i,r){const s=(0,t.g2)("QuestionList");return(0,t.uX)(),(0,t.CE)("div",null,[$,(0,t.bF)(s,{questions:i.questions},null,8,["questions"])])}var ee=JSON.parse('[{"question":"Operacje na liczbach zmiennoprzecinkowych - Co zwróci poniższy kod?","code":"console.log(0.1 + 0.2 === 0.3);","explanation":"false. Operacje na liczbach zmiennoprzecinkowych w JavaScript mogą prowadzić do błędów zaokrągleń. 0.1 + 0.2 w rzeczywistości wynosi 0.30000000000000004."},{"question":"Typ NaN - Co zwróci poniższy kod?","code":"console.log(typeof NaN);","explanation":"\'number\'. NaN (Not-a-Number) jest specyficznym typem liczbowym w JavaScript."},{"question":"Różnice między `let`, `var` i `const`","explanation":"`var` ma zakres funkcji i jest hoistowany (może być używany przed zdefiniowaniem). `let` ma zakres blokowy i nie jest hoistowany w ten sam sposób co `var`. `const` ma zakres blokowy jak `let`, ale deklaruje zmienne, które nie mogą być reasignowane."},{"question":"Referencje obiektów - Co zwróci poniższy kod?","code":"let a = {}; let b = a; a.foo = \'bar\'; console.log(b.foo);","explanation":"\'bar\'. b jest referencją do tego samego obiektu co a, więc zmiany w a będą widoczne w b."},{"question":"Zakres zmiennych i asynchroniczność - Co zwróci poniższy kod?","code":"for (var i = 0; i < 3; i++) { setTimeout(() => console.log(i), 1000); }","explanation":"3\\n3\\n3. var ma zakres funkcji, więc wartość i jest współdzielona w całej funkcji. Po zakończeniu pętli, i wynosi 3."},{"question":"Jak naprawić powyższy kod, aby wyświetlał 0, 1, 2?","code":"for (let i = 0; i < 3; i++) { setTimeout(() => console.log(i), 1000); }","explanation":"Użycie `let` zapewnia zakres blokowy, dzięki czemu każda iteracja ma swoją własną kopię `i`."},{"question":"Porównanie null i undefined - Co zwróci poniższy kod?","code":"console.log(null == undefined);\\nconsole.log(null === undefined);","explanation":"true\\nfalse. null i undefined są równe przy użyciu operatora ==, ale nie są identyczne (===)."},{"question":"Automatyczne wstawianie średników - Co zwróci poniższy kod?","code":"function foo() { return\\n{ bar: \'hello\' }; }\\nconsole.log(foo());","explanation":"undefined. Automatyczne wstawianie średników powoduje, że return jest zakończone przed obiektem, więc funkcja zwraca undefined."},{"question":"Konkatenacja tablic jako stringi - Co zwróci poniższy kod?","code":"console.log([1, 2, 3] + [4, 5, 6]);","explanation":"\\"1,2,34,5,6\\". Operacja + konwertuje tablice na stringi i konkatenuje je."},{"question":"Referencje obiektów a zmiana wartości - Co zwróci poniższy kod?","code":"let x = { foo: 1 }; let y = x; x.foo = 2; console.log(y.foo);","explanation":"2. x i y wskazują na ten sam obiekt, więc zmiana foo w x zmienia również foo w y."},{"question":"Co to jest `this` w JavaScript i jak działa w różnych kontekstach?","explanation":"`this` jest kontekstowym wskaźnikiem w JavaScript, który odnosi się do obiektu, na którym jest wywoływana dana funkcja. W zależności od kontekstu wywołania, `this` może wskazywać na różne obiekty:\\n- W funkcji wywoływanej w globalnym kontekście, `this` wskazuje na globalny obiekt (`window` w przeglądarkach).\\n- W metodzie obiektu, `this` wskazuje na ten obiekt.\\n- W konstruktorze, `this` wskazuje na nowo utworzoną instancję.\\n- W funkcjach strzałkowych (`arrow functions`), `this` jest leksykalnie wiązane do otaczającego kontekstu."},{"question":"Czym jest hoisting w JavaScript?","explanation":"Hoisting to mechanizm JavaScript, w którym deklaracje zmiennych i funkcji są przenoszone na górę swojego zakresu (scope) przed wykonaniem kodu. Oznacza to, że zmienne i funkcje mogą być używane przed ich faktycznym zadeklarowaniem w kodzie."},{"question":"Jaka jest różnica między `==` a `===` w JavaScript?","explanation":"`==` to operator porównania równości, który sprawdza równość dwóch wartości po przekształceniu ich na ten sam typ (równanie z przekształceniem typu). `===` to operator porównania ścisłej równości, który sprawdza zarówno wartość, jak i typ, bez wykonywania przekształceń (równanie bez przekształcenia typu)."},{"question":"Co to jest event loop w JavaScript?","explanation":"Event loop to mechanizm w JavaScript odpowiedzialny za zarządzanie wykonaniem kodu, zbieraniem i przetwarzaniem zdarzeń oraz obsługą asynchronicznych operacji (jak callbacki, obietnice). Główna pętla zdarzeń monitoruje stos wywołań (call stack) i kolejkę komunikatów (message queue), przetwarzając jeden komunikat na raz."},{"question":"Co to jest closures w JavaScript?","explanation":"Closures to funkcje, które mają dostęp do zakresu zmiennych z zewnętrznej funkcji, w której zostały zadeklarowane, nawet po zakończeniu tej zewnętrznej funkcji. Closure zachowuje referencje do zmiennych z zewnętrznego zakresu, umożliwiając dostęp do tych zmiennych później."},{"question":"Wyjaśnij różnice między funkcją strzałkową a funkcją regularną.","explanation":"- Funkcje strzałkowe (`arrow functions`) mają krótszą składnię.\\n- Funkcje strzałkowe nie mają własnego `this` i `arguments`, dziedziczą `this` z otaczającego kontekstu.\\n- Funkcje strzałkowe nie mogą być używane jako konstruktory."},{"question":"Co to jest prototyp i jak działa w JavaScript?","explanation":"Prototyp to obiekt, z którego inne obiekty dziedziczą właściwości i metody. Każdy obiekt w JavaScript ma wewnętrzne odniesienie do prototypu (`__proto__`), który jest łańcuchem prototypów (`prototype chain`). Dziedziczenie w JavaScript jest realizowane poprzez te łańcuchy prototypów."},{"question":"Co to jest „use strict” i dlaczego jest używany?","explanation":"`\\"use strict\\"` to dyrektywa wprowadzająca tryb ścisły w JavaScript, który zmienia pewne błędne lub niebezpieczne zachowania języka. W trybie ścisłym:\\n- Nie można używać niezadeklarowanych zmiennych.\\n- `this` w funkcji, która nie jest metodą obiektu, jest `undefined`.\\n- Wywołania błędnych operacji, jak usuwanie nieusuwalnych właściwości, generują błędy."},{"question":"Jaka jest różnica między `null` a `undefined`?","explanation":"- `undefined` oznacza, że zmienna została zadeklarowana, ale nie przypisano jej wartości.\\n- `null` jest wartością przypisywaną celowo, oznaczającą brak wartości."},{"question":"Co to jest moduł i jak działa system modułów w JavaScript (ES6)?","explanation":"Moduł to plik zawierający kod JavaScript, który eksportuje i importuje określone elementy (jak zmienne, funkcje, klasy) do innych modułów. ES6 wprowadził system modułów, który wykorzystuje dyrektywy `import` i `export`:\\n- `export` pozwala na eksportowanie zmiennych, funkcji lub klas z modułu.\\n- `import` pozwala na importowanie eksportowanych elementów z innych modułów.","code":"// math.js\\nexport function add(a, b) {\\n  return a + b;\\n}\\n\\n// main.js\\nimport { add } from \'./math.js\';\\nconsole.log(add(2, 3)); // 5"},{"question":"Jakie są różne metody komunikacji między komponentami w Vue.js?","explanation":"Vue.js oferuje kilka metod komunikacji między komponentami: Props i Emit, Provide/Inject, Event Bus, Vuex. Props i Emit służą do przesyłania danych i zdarzeń między komponentami nadrzędnymi i podrzędnymi. Provide/Inject umożliwia przekazywanie danych do głębiej zagnieżdżonych komponentów. Event Bus pozwala na prostszą komunikację zdarzeń między niepowiązanymi komponentami, a Vuex jest biblioteką do zarządzania stanem aplikacji centralnie."},{"question":"Jak działa dwukierunkowe wiązanie danych (two-way data binding) w Vue.js?","explanation":"Dwukierunkowe wiązanie danych w Vue.js jest realizowane za pomocą dyrektywy `v-model`. Pozwala ona na automatyczną synchronizację wartości między komponentem a jego modelem danych, co oznacza, że zmiany w modelu danych będą odzwierciedlane w widoku i odwrotnie."},{"question":"Jak wykorzystać teleportację w Vue 3?","explanation":"Teleportacja w Vue 3 pozwala przenosić treść komponentów do innych części DOM bez naruszania logiki CSS i zachowania reaktywności. Używa się komponentu <teleport>, aby określić miejsce, do którego ma zostać przeniesiona treść."},{"question":"Co to są dyrektywy w Vue.js i jakie znasz przykłady?","explanation":"Dyrektywy w Vue.js to specjalne atrybuty używane w szablonach, które pozwalają manipulować DOM. Przykłady to `v-if` (renderowanie warunkowe), `v-for` (pętle), `v-bind` (powiązanie atrybutów) i `v-on` (obsługa zdarzeń)."},{"question":"Co to jest Vuex i kiedy warto go używać?","explanation":"Vuex to biblioteka do zarządzania stanem dla aplikacji Vue.js, umożliwiająca centralne zarządzanie stanem. Jest przydatny w złożonych aplikacjach, gdzie zarządzanie stanem może być trudne. Vuex pozwala na przejrzyste zarządzanie stanem, obsługę asynchronicznych operacji i ułatwia debugowanie oraz testowanie."},{"question":"Co to jest event bubbling i capturing?","explanation":"Event bubbling to mechanizm, w którym zdarzenie jest najpierw obsługiwane przez najgłębiej zagnieżdżony element, a następnie propaguje się w górę drzewa DOM. Event capturing to proces, w którym zdarzenie jest obsługiwane najpierw przez elementy nadrzędne, zaczynając od korzenia dokumentu, a kończąc na najgłębiej zagnieżdżonym elemencie. Oba mechanizmy umożliwiają zarządzanie propagacją zdarzeń w DOM."},{"question":"Wyjaśnij, czym jest Promise w JavaScript i jak działa.","explanation":"Promise w JavaScript to obiekt, który reprezentuje zakończenie (lub niepowodzenie) operacji asynchronicznej i jej wynik. Promise może być w jednym z trzech stanów: pending (oczekujący), fulfilled (zrealizowany), lub rejected (odrzucony). Promise pozwala na wykonywanie operacji asynchronicznych w bardziej czytelny sposób niż tradycyjne callbacki."},{"question":"Jakie są różnice między `async`/`await` a użyciem `.then()` i `.catch()` dla promises?","explanation":"`async`/`await` to składnia, która pozwala pisać kod asynchroniczny w sposób bardziej przypominający kod synchroniczny. `await` może być używane tylko wewnątrz funkcji oznaczonej jako `async`. `async`/`await` sprawia, że kod asynchroniczny jest bardziej czytelny i łatwiejszy do zrozumienia. `.then()` i `.catch()` są metodami używanymi do obsługi promise, co może prowadzić do zagnieżdżenia callbacków."},{"question":"Co to jest Promise.all i jak go używać?","explanation":"`Promise.all` to metoda, która przyjmuje iterowalny obiekt (np. tablicę) promes i zwraca jedną promesę, która rozwiązuje się, gdy wszystkie promesy w iterowalnym obiekcie zostaną rozwiązane, lub odrzuca się, gdy któraś z promes zostanie odrzucona. Jest używana, gdy chcesz uruchomić wiele operacji asynchronicznych równolegle i poczekać, aż wszystkie zakończą się przed kontynuowaniem dalszych operacji."},{"question":"Lifecycle hooks w Vue - jeśli używam script setup? Wytłumacz mi to.","explanation":"W Vue 3 przy użyciu script setup, lifecycle hooks są wywoływane poprzez specjalne funkcje bezpośrednio w setup() lub script setup. Przykłady: onMounted(), onUpdated(), onUnmounted().","code":"<script setup>\\nimport { onMounted, ref } from \'vue\';\\n\\nconst count = ref(0);\\nonMounted(() => {\\n  console.log(\'Komponent został zamontowany\');\\n});\\n<\/script>"},{"question":"Jak wygląda event bubbling i event capturing w Vue?","explanation":"Event bubbling i event capturing w Vue działają zgodnie z natywnym mechanizmem JavaScript, ale Vue oferuje wygodne narzędzia do zarządzania zdarzeniami. Domyślnie zdarzenia są obsługiwane w fazie bąbelkowania, ale można użyć modyfikatora `.capture`, aby obsłużyć zdarzenia w fazie przechwytywania.","code":"<template>\\n  <div id=\\"outer\\" @click.capture=\\"onOuterClick\\">\\n    <div id=\\"inner\\" @click=\\"onInnerClick\\">\\n      Kliknij mnie\\n    </div>\\n  </div>\\n</template>\\n\\n<script>\\nexport default {\\n  methods: {\\n    onOuterClick() {\\n      alert(\'Outer div clicked during capturing phase!\');\\n    },\\n    onInnerClick() {\\n      alert(\'Inner div clicked!\');\\n    }\\n  }\\n};\\n<\/script>"},{"question":"Co to jest reaktywność? Jak Vue.js obsługuje reaktywność? Jak działa system reaktywności Vue.js?","explanation":"Reaktywność to mechanizm, który automatycznie aktualizuje interfejs użytkownika, gdy zmieniają się dane aplikacji. W Vue 3 system reaktywności opiera się na Proxy API, które pozwala Vue śledzić zmiany w obiektach i tablicach. ref() i reactive() są podstawowymi narzędziami do tworzenia reaktywnych danych.","code":"<script setup>\\nimport { ref, reactive } from \'vue\';\\n\\nconst count = ref(0);\\nconst state = reactive({ message: \'Hello\' });\\n<\/script>"},{"question":"Jaka jest różnica pomiędzy ref a reactive?","explanation":"ref() jest używane do tworzenia prostych, reaktywnych wartości, takich jak liczby czy stringi, natomiast reactive() jest używane do tworzenia reaktywnych obiektów i tablic. ref() zwraca obiekt z właściwością .value, podczas gdy reactive() zwraca Proxy obiektu, który jest bezpośrednio modyfikowany.","code":"<script setup>\\nimport { ref, reactive } from \'vue\';\\n\\nconst count = ref(0);\\nconst state = reactive({ message: \'Hello\' });\\n<\/script>"},{"question":"Co się stanie, jeśli użyjemy ref do obiektu lub listy?","explanation":"Jeśli użyjemy ref do obiektu lub listy, obiekt ten będzie nadal reaktywny, ale dostęp do właściwości obiektu będzie wymagał użycia .value. Dla skomplikowanych struktur lepiej jest używać reactive.","code":"<script setup>\\nimport { ref } from \'vue\';\\n\\nconst state = ref({ count: 0, items: [1, 2, 3] });\\nconsole.log(state.value.count); // Dostęp przez .value\\n<\/script>"},{"question":"Jaka jest różnica pomiędzy normalnym watch a tym nowym z Vue 3?","explanation":"watch() w Vue 3 jest używane do reagowania na zmiany specyficznych reaktywnych zmiennych, podczas gdy watchEffect() automatycznie śledzi zależności użyte wewnątrz swojej funkcji i reaguje na ich zmiany bez potrzeby jawnego określania zależności.","code":"<script setup>\\nimport { ref, watch, watchEffect } from \'vue\';\\n\\nconst count = ref(0);\\nwatch(count, (newValue, oldValue) => {\\n  console.log(`count zmienił się z ${oldValue} na ${newValue}`);\\n});\\n\\nwatchEffect(() => {\\n  console.log(`count to teraz ${count.value}`);\\n});\\n<\/script>"},{"question":"Jak działa dwukierunkowe wiązanie danych (two-way data binding) w Vue.js?","explanation":"Dwukierunkowe wiązanie danych w Vue.js jest realizowane za pomocą dyrektywy v-model. v-model wiąże wartość zmiennej do elementu formularza i automatycznie aktualizuje zmienną, gdy użytkownik wprowadza dane.","code":"<template>\\n  <input v-model=\\"message\\" />\\n  <p>{{ message }}</p>\\n</template>\\n\\n<script>\\nexport default {\\n  data() {\\n    return {\\n      message: \'Hello\'\\n    };\\n  }\\n};\\n<\/script>"},{"question":"Jak wykorzystać teleportację w Vue 3?","explanation":"Teleportacja w Vue 3 umożliwia przenoszenie treści komponentów do innych części DOM bez naruszania logiki CSS i zachowania reaktywności. Używa się komponentu <teleport> z atrybutem to, aby określić, gdzie w DOM należy przenieść zawartość.","code":"<template>\\n  <teleport to=\\"#modal\\">\\n    <div class=\\"modal-content\\">\\n      <p>To jest teleportowana treść.</p>\\n    </div>\\n  </teleport>\\n</template>\\n\\n<script>\\nexport default {\\n};\\n<\/script>"},{"question":"Co to są dyrektywy w Vue.js i jakie znasz przykłady?","explanation":"Dyrektywy w Vue.js to specjalne atrybuty, które umożliwiają wykonywanie działań na elementach DOM. Przykłady dyrektyw to: v-if, v-for, v-bind, v-model, v-on.","code":"<template>\\n  <div v-if=\\"show\\">Pokazuj mnie</div>\\n  <ul>\\n    <li v-for=\\"item in items\\" :key=\\"item.id\\">{{ item.name }}</li>\\n  </ul>\\n  <input v-model=\\"message\\" />\\n  <button @click=\\"handleClick\\">Kliknij mnie</button>\\n</template>\\n\\n<script>\\nexport default {\\n  data() {\\n    return {\\n      show: true,\\n      items: [\\n        { id: 1, name: \'Item 1\' },\\n        { id: 2, name: \'Item 2\' }\\n      ],\\n      message: \'Hello\'\\n    };\\n  },\\n  methods: {\\n    handleClick() {\\n      alert(this.message);\\n    }\\n  }\\n};\\n<\/script>"},{"question":"Co to jest Vuex i kiedy warto go używać?","explanation":"Vuex jest biblioteką do zarządzania stanem dla aplikacji Vue.js. Jest szczególnie przydatny w złożonych aplikacjach, gdzie wiele komponentów musi współdzielić stan. Vuex centralizuje zarządzanie stanem, ułatwiając debugowanie i testowanie.","code":"// store.js\\nimport { createStore } from \'vuex\';\\n\\nconst store = createStore({\\n  state() {\\n    return {\\n      count: 0\\n    };\\n  },\\n  mutations: {\\n    increment(state) {\\n      state.count++;\\n    }\\n  },\\n  actions: {\\n    increment(context) {\\n      context.commit(\'increment\');\\n    }\\n  },\\n  getters: {\\n    count: state => state.count\\n  }\\n});\\n\\nexport default store;\\n\\n// main.js\\nimport { createApp } from \'vue\';\\nimport App from \'./App.vue\';\\nimport store from \'./store\';\\n\\ncreateApp(App).use(store).mount(\'#app\');"},{"question":"Co to jest event bubbling i jak działa? Co to jest event bubbling and capturing?","explanation":"Event bubbling to proces, w którym zdarzenie najpierw jest obsługiwane przez najgłębiej zagnieżdżony element, na którym zostało wywołane, a następnie propaguje się w górę drzewa DOM do jego elementów nadrzędnych. Event capturing to proces, w którym zdarzenie jest obsługiwane najpierw przez elementy nadrzędne, zaczynając od korzenia dokumentu, a kończąc na najgłębiej zagnieżdżonym elemencie, na którym zostało wywołane.","code":"\x3c!-- HTML --\x3e\\n<!DOCTYPE html>\\n<html lang=\\"en\\">\\n<head>\\n  <meta charset=\\"UTF-8\\">\\n  <title>Event Bubbling Example</title>\\n</head>\\n<body>\\n  <div id=\\"outer\\">\\n    <div id=\\"inner\\">\\n      Kliknij mnie\\n    </div>\\n  </div>\\n  <script>\\n    document.getElementById(\'inner\').addEventListener(\'click\', function(event) {\\n      alert(\'Inner div clicked!\');\\n    });\\n\\n    document.getElementById(\'outer\').addEventListener(\'click\', function(event) {\\n      alert(\'Outer div clicked!\');\\n    });\\n  <\/script>\\n</body>\\n</html>"},{"question":"Różnice pomiędzy funkcjami anonimowymi, strzałkowymi i standardowymi w JavaScript?","explanation":"Funkcje anonimowe nie mają nazwy i są często używane jako argumenty do innych funkcji. Funkcje strzałkowe mają krótszą składnię i nie mają własnego this oraz arguments, dziedzicząc this z otaczającego kontekstu. Standardowe funkcje mają własne this, które jest wiązane w momencie wywołania funkcji.","code":"// Anonimowa funkcja\\nconst anonFunc = function() {\\n  console.log(\'Anonimowa funkcja\');\\n};\\n\\n// Funkcja strzałkowa\\nconst arrowFunc = () => {\\n  console.log(\'Funkcja strzałkowa\');\\n};\\n\\n// Standardowa funkcja\\nfunction standardFunc() {\\n  console.log(\'Standardowa funkcja\');\\n}\\n\\nanonFunc(); // Anonimowa funkcja\\narrowFunc(); // Funkcja strzałkowa\\nstandardFunc(); // Standardowa funkcja"}]'),ne={name:"JavaScriptView",components:{QuestionList:B},data(){return{questions:ee}}};const ae=(0,c.A)(ne,[["render",Y],["__scopeId","data-v-0eb592fa"]]);var oe=ae;function te(e,n,a,o,i,r){return(0,t.uX)(),(0,t.CE)("div",null," Autoryzowanie... ")}a(4114);var ie={created(){this.$auth.authenticate("github",this.$route.query).then((()=>{this.$router.push({path:"/"})})).catch((e=>{console.error("Error authenticating:",e)}))}};const re=(0,c.A)(ie,[["render",te]]);var se=re;const ce=[{path:"/",name:"home",component:j},{path:"/python",name:"python",component:K},{path:"/javascript",name:"javascript",component:oe},{path:"/auth/callback",name:"AuthCallback",component:se}],le=(0,u.aE)({history:(0,u.LA)(),routes:ce});var de=le,ue=a(9529);const pe=(0,o.Ef)(d);pe.use(de),pe.use(ue.Ay,{property:{id:"G-5RTJ4VSD2H"}}),pe.mount("#app")}},n={};function a(o){var t=n[o];if(void 0!==t)return t.exports;var i=n[o]={exports:{}};return e[o].call(i.exports,i,i.exports,a),i.exports}a.m=e,function(){var e=[];a.O=function(n,o,t,i){if(!o){var r=1/0;for(d=0;d<e.length;d++){o=e[d][0],t=e[d][1],i=e[d][2];for(var s=!0,c=0;c<o.length;c++)(!1&i||r>=i)&&Object.keys(a.O).every((function(e){return a.O[e](o[c])}))?o.splice(c--,1):(s=!1,i<r&&(r=i));if(s){e.splice(d--,1);var l=t();void 0!==l&&(n=l)}}return n}i=i||0;for(var d=e.length;d>0&&e[d-1][2]>i;d--)e[d]=e[d-1];e[d]=[o,t,i]}}(),function(){a.d=function(e,n){for(var o in n)a.o(n,o)&&!a.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:n[o]})}}(),function(){a.g=function(){if("object"===typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"===typeof window)return window}}()}(),function(){a.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)}}(),function(){var e={524:0};a.O.j=function(n){return 0===e[n]};var n=function(n,o){var t,i,r=o[0],s=o[1],c=o[2],l=0;if(r.some((function(n){return 0!==e[n]}))){for(t in s)a.o(s,t)&&(a.m[t]=s[t]);if(c)var d=c(a)}for(n&&n(o);l<r.length;l++)i=r[l],a.o(e,i)&&e[i]&&e[i][0](),e[i]=0;return a.O(d)},o=self["webpackChunkfaq_app"]=self["webpackChunkfaq_app"]||[];o.forEach(n.bind(null,0)),o.push=n.bind(null,o.push.bind(o))}();var o=a.O(void 0,[504],(function(){return a(8596)}));o=a.O(o)})();
//# sourceMappingURL=app.73370e33.js.map